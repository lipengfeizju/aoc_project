#ifndef FLA_DPM_DETECTOR_H_
#define FLA_DPM_DETECTOR_H_

#include "ros/ros.h"
#include <image_transport/image_transport.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Pose.h>
#include <sensor_msgs/Image.h>
#include <stereo_msgs/DisparityImage.h>
#include <sensor_msgs/CameraInfo.h>
#include <camera_info_manager/camera_info_manager.h>
#include <sensor_msgs/RegionOfInterest.h>
#include <nav_msgs/Odometry.h>
#include <opencv/cv.h>
#include <cv_bridge/cv_bridge.h>
#include <string>
#include <math.h>
#include "dpm_detect_client.h"

#include <image_transport/subscriber_filter.h>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/exact_time.h>

#include <image_geometry/stereo_camera_model.h>
#include <image_geometry/pinhole_camera_model.h>
#include <tf/transform_datatypes.h>

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "undistorter.h"

namespace fla_dpm_detector {

class FlaDpmDetector {
public:
  FlaDpmDetector(ros::NodeHandle nh_in, int param_option,
                 double starting_distance_in, bool debug,
		 sensor_msgs::CameraInfo cinfo_left_in,
		 sensor_msgs::CameraInfo cinfo_right_in);
  ~FlaDpmDetector();

  void publish();

  double rate;

protected:
  void startImageSub();
  void odomCb(const nav_msgs::Odometry::ConstPtr &odom_in);
  void imgCb(const sensor_msgs::ImageConstPtr& l_image_msg,
	     //const sensor_msgs::CameraInfoConstPtr& l_info_msg,
	     const sensor_msgs::ImageConstPtr& r_image_msg);
	     //const sensor_msgs::CameraInfoConstPtr& r_info_msg);

  ros::NodeHandle nh;
  ros::Subscriber cam_odom_sub, image_sub;
  image_transport::Publisher image_pub, pub_rect_left_, pub_rect_right_;
  ros::Publisher disp_pub, pose_pub;
  image_transport::ImageTransport it;

  dpm_detect_client::DpmDetectClient dpm_client;

  geometry_msgs::Pose goal_pose;

  double starting_distance, resize_val, error_tol;
  bool odom_received;
  
  typedef message_filters::sync_policies::ExactTime<sensor_msgs::Image, /*sensor_msgs::CameraInfo,*/ sensor_msgs::Image/*, sensor_msgs::CameraInfo*/> ExactPolicy;
  typedef message_filters::Synchronizer<ExactPolicy> ExactSync;
  image_transport::SubscriberFilter sub_l_image_, sub_r_image_;
  //message_filters::Subscriber<sensor_msgs::CameraInfo> sub_l_info_, sub_r_info_;
  image_geometry::PinholeCameraModel left_model_, right_model_;;

  sensor_msgs::CameraInfo cinfo_left, cinfo_right;
  geometry_msgs::Pose cam_odom_pose;
  std::vector<bool> valid_pose;
  std::vector<tf::Transform> cam_odom_vec;
  std::vector<tf::Transform> polaris_pos_vec;

  boost::shared_ptr<ExactSync> exact_sync_;
  image_geometry::StereoCameraModel stereo_model_;
  
  cv::StereoBM block_matcher_;

  int num_ima;
};
}

#endif
